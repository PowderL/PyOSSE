""" Class for a group of fields generated by CTM models

    Authors: L. Feng, Edinburgh University
    History: v0.5, 2012.06.28
    History: v0.95, 2012.12.12
    

    Classes:
    ---------------------------------------------------------------
    1. ctm_world_cl: general container for gridded geo-physical variables
    
    
""" 
import numpy as npy
# from scipy import *

import ESA.util.geo_constant as gc
import ESA.util.otool_obj as oob
import ESA.util.gp_axis_m as gax
import ESA.util.message_m as msm

import ctm_grid_3d as cgrd
import gc_grid_3d as gcgrd

import ctm_field_m as field_cl
import ctm_profile_m as cprofile_m


class ctm_world_cl:
    """ general container for gridded geo-physical variables
    
    Members:
    ------------------------------------------------------------------------------
    
    1. name  :<str>: # name for the object
    2. ctm_grd: <ctm_grd_cl>: time tag for the object 
    3. time_tag:<str/float>: to track time 
    4. __data_list: <list>: list of ctm_field_cl objections
    5. attr_dict:<dict>: dictionary for attributes
    6. ndata: <integer>: length of the data set 
    
    Functions:
    ---------------------------------------
    
    # member retrieve 
    
    1. find_data:   search data matching selection criteria of name, tracer_id, tracer_name, \
    category, group and time range etc 
    
    
    
    # member manage 
    3. add_data: add data to the list 
    4. del_data: delete data from the list
    5. update_data: update data
    6. copy_data: get a copy of the data
    7. get_data: return the data (shared the same address of the data member)
    
     
    # Interpolation 
    
    7. get_ctm_grd: return the ctm_grd member 
    8. copy_ctm_grd: get a copy of the ctm_grd 
    
    
    7. get_gp_slice: get vertical profiles of for select tracer name at locations 
    
    # IO 
    8. load_gp_from_file: load variable from file(s)
    9. save_gp_to_file:  save variable to file(s)
    10. __getitem__: over-riding index 
    
        
    """
    
    def __init__(self,name, data_lst, ctm_grd=None,\
                 time_tag="", extra_axis=None, \
                     **keywords):
        
        """Initialize 
        
        Inputs:
        --------------------------------
        1. name  :<str>: # name for the object
        2. data_list: <dict>: list of ctm_field_cl objections
        3. ctm_grd: <ctm_grd_cl>: time tag for the object 
        4. time_tag:<str/float>: time 
        """
        
        self.attr_dict={}
        self.attr_dict.update({'ot_type': oob.ot_world})
        self.name=name
        self.attr_dict.update({'name':self.name})
        
        self.ndata=0
        self.__data_lst=[]
        
        for cdata in data_lst:
            self.add_data(cdata)
        
        # set grid type
        self.ctm_grd=None
        if (ctm_grd<>None):
            self.set_grid(ctm_grd)
        
        
        
        self.time_tag=time_tag
        self.attr_dict.update({'time_tag':self.time_tag})
        
        
        # S4 assign extral axis (such as time, or ensemble index etc)
        
        self.extra_axis=None
        
        if (extra_axis==None):
            self.extra_axis=None
        else:
            if (oob.check_type(extra_axis, oob.ot_axis)):
                self.extra_axis=extra_axis
            else:
                msm.show_err_msg('extra axis', msm.msm_wrong_type)
        
                
        
        for keyname in keywords:
            keyval=keywords[keyname]
            self.set_attr(keyname, keyval)
    
    def set_grid(self, ctm_grd):
    
        """ define the grid 
        Inputs: 
        1.ctm_grid:<ctm_grid_cl>: grid
        """
        
        if (ctm_grd==None):
            self.ctm_grd=ctm_grd
        else:
            if (oob.check_type(ctm_grd, oob.ot_grid)):
                self.ctm_grd=ctm_grd
            else:
                msm.show_err_msg('ctm_grid', msm.msm_wrong_type)
        
    
    def add_data(self, data):
        
        """
        Add data (ctm_field_cl) into the class 
        Inputs:
        ------------------------------
        1. data:<ctm_field_cl>: class for ctm data
        """
        
        if (oob.check_type(data, oob.ot_field)):
            self.__data_lst.append(data)
            self.ndata=self.ndata+1
            print 'len', len(self.__data_lst)
            
        else:
            msm.show_err_msg('data', msm.msm_wrong_type)
        
        
    def find_data(self, **keywords):
        """
        find the data meeting the requirements 
        
        Inputs:
        ----------------------------------------
        
        1. keywords:<dict>: list of criteria 
        
        Returns:
        ------------------------------------------
        1. found_data:<list, t:ctm_field_cl>: datasets meeting the criteria
        
        """
        
        found_data=[]
        ifound=0
        
        for data in self.__data_lst:
            matched=data.is_matched(**keywords)
            if (matched):
                ifound=ifound+1
                
                found_data.append(data)
        if (ifound>0):
            return found_data
        else:
            return None
        
    def add_attr(self, name, val):
        """
        add or replace attributes
        Inputs
        ---------------------------------
        1. name:<str>: attribute name
        2. val: <obj>: value of the attribute
        
        
        """
            
        if (name=='time_tag'):
            self.time_tag=time_tag
            self.attr_dict.update({name:val})
       
        elif (name=='name'):
            self.name=name
            self.attr_dict.update({name:val})
        else:
            self.attr_dict.update({name:val})
        
            

    def get_attr(self, name):
        """
        check attribute
        Inputs:
        ---------------------------------------------
        1. name:<str>: attribute name
        
        Returns:
        ----------------------------------------------
        1. val:<obj>: value of the attribute
        
        """
        
        if (name in self.attr_dict):
            return self.attr_dict[name]
        else:
            msm.show_err_msg(name, msm.msm_no_attr)
            return None
    
    def copy_attr_dict(self):
    
        """ copy the attribute dictionary 
        """
        return dict(self.attr_dict)
    
    
    

    def get_grid(self):
        """
        get ctm grid
        Returns:
        1. ctm_grd:<ctm_grid_cl>: ctm grid
        """

        return self.ctm_grd

    def is_data_in_list(self, data, keys):
        """
        check whether a data is in the __data_list 
        
        Inputs:
        1. data:<ctm_field_cl>: CTM fileds
        2. keys:<list, t:string>: a list of key should be checked. 

        Returns:
        1. is_found:<integer>: if a data set with the same attributes of data input  
        is found in the list, its index will be given; 
        Otherwise, oob.fill_val_int will be returned
        
        """
        
        is_found=oob.fill_val_int
        search_list={}
        
        if  (get_ot_type(obj)<>ot_field):
            return if_found
        
        for keyname in keys:
            if (keyname in key):
                keyval=data.get_attr(keyname)
                search_list.append({keyname:keyval})
                
            else:
                return is_found
        i=0
        for data_obj in self.__data_list:
            match=idata_obj.is_matched(data.name, **search_list)
            if (is_match):
                is_found=i
                return is_found
            
            i=i+1
        
        
            
    def read_data_from_file(self, yyyy, mm, dd, varnames_lst, key_lst, file_read_m):
        """ virtual function 
        
        """
        
        file_read_m.open_file_read(flnm, yyyy, mm, dd, varname_lst, key_lst)
        data_lst=file_read_m.read_data()
        for data in data_lst:
            idx=self.is_data_in_list(data, key_lst)
            if (idx==gc.fill_val_int):
                self.__data_lst.append(data)
            else:
                self.__data_lst[idx]=data
                
        
        file_read_m.close()
    
    def __delitem__(self, index):

        """             
        Inputs:
        ------------------------------------------------
        1. index:<integer/slice/string>: 
        ---Index for elements in __data_lst when integer or slice is provided  
        ---name of the elements in __data_lst when string is provided
        
        Outputs:
        ------------------------------------------------
        1. ndel:<integer>: number of elements deleted from __data_lst
        
        """
        
        otype=oob.get_ot_type(index)
        old_ndata=len(self.__data_lst)
        
        
        if (otype==oob.ot_string):
            # search by name 
            
            idx_st=0
            idx=0
            
            # T1 delete all items with the given name
            
            while (idx_st<self.ndata):
                idx=idx_st
                
                for data in self.__data_lst[idx_st:]:
                    matched=data.is_matched(name=index)
                    #  print idx, index, data.name, matched
                    
                    if (matched):
                        del self.__data_lst[idx]
                        self.ndata=len(self.__data_lst)
                        
                        idx_st=idx
                        idx=0
                        break
                    else:                    
                        idx=idx+1
                
                if (idx>idx_st):
                    idx_st=idx
        
        elif (otype==oob.ot_int): # by name 
            del  sel.__data_lst[idx]
            
        elif (otype==oob.ot_slice): # by slice
            del self.__data_lst[index]
            
        else:
            msm.show_err_msg(index, msm.msm_wrong_index)
            
        self.ndata=len(self.__data_lst)
        
        return old_ndata-self.ndata
    
          

    def __getitem__(self, index):
        """
        over-ridding index function
        
        Inputs:
        ------------------------------------------------
        1. index:<integer/slice/string>: 
        ---Index for elements in __data_lst when integer or slice is provided  
        ---name of the elements in __data_lst when string is provided

        Outputs:
        ------------------------------------------------
        1. data_lst:<list, t:ctm_field_cl>: list of data 

        """
        otype=oob.get_ot_type(index)
        if (otype==oob.ot_string): 
            # by name 
            data_lst=self.find_data(name=index)
            if (data_lst<>None):
                return data_lst
            else:
                msm.show_err_msg(index, msm.msm_wrong_index)
                return None
            
        elif (otype==oob.ot_int): # integer
            
            if (index<self.ndata):
                data_lst=self.__data_lst[index]
                return data_lst
            
            else:
                msm.show_err_msg(index, msm.msm_wrong_index)
                return None
        
        elif (otype==oob.ot_slice): # slice
            return self.__data_lst[index]
        
        else:
            msm.show_err_msg(index, msm.msm_wrong_index)
            return None
        
    
    def get_gp_slice(self, olon, olat, **gp_keys):
        """
        get profiles for variables at given locations. 
        Inputs:
        -------------------------------------------------
        1. olon:<array, (nob,)>: longitudes
        2. olat:<array, (nob,)>: latitudes
        3. gp_keys:<dict>: selection criteria
        
        Returns:
        --------------------------------------
        1. name_lst: <list,t:str>: name of the profiles
        2. prof_lst: <list, t:ctm_profile_cl>: list of the profiles 
        
        
        
        """
        
        # S1: build the interpolation class
        # print olon
        # print olat
        

        if (not oob.check_type(self.ctm_grd, oob.ot_grid)):
            msm.show_err_msg('ctm_grd has not been properly set')
            return None
        
        # ##T: get the interpolate class
        
        hintpl=self.ctm_grd.get_hintpl(olon, olat)
            
        # S2: find data list meeting the criteria 
        
        data_lst=self.find_data(**gp_keys)
        ndata=len(data_lst)
        
        if (ndata==0):
            msg='No data set found'
            msm.show_err_msg(msg)
            return None
        
        # S3: interpolate the fields to the locations 
        
        prof_lst=list()
        name_lst=list()
        
        for data_obj in data_lst:
            rdata=data_obj.copy_data()
            
            # interpolate the data to profile locations 
            
            profs=hintpl.get_profile(rdata)
            # attributes
            
            attrs=data_obj.copy_attr_dict()
            # constructure the profile 
            # avoid possible duplications 
            
            if ('name' in attrs):
                del attrs['name']
            elif ('lon' in attrs):
                del attrs['lon']
                
            elif ('lat' in attrs):
                del attrs['lat']
                
            elif ('ot_type' in attrs):
                del attrs['ot_type']
            
            
            cprof=cprofile_m.ctm_profile_cl(data_obj.name, profs,\
                                                lon=olon,\
                                                lat=olat,\
                                                is_xz_data=data_obj.is_xyz_data, \
                                                extra_axis=data_obj.extra_axis, \
                                                **attrs)
            
                                           
            
            
            prof_lst.append(cprof)
            name_lst.append(data_obj.name)
        
        return name_lst, prof_lst

    
    




if (__name__=="__main__"):
    print '>1. form a grid 4x5 with 47 levels:'
    cm=gcgrd.gc_grid_cl(0, 0, 47, mod_res='4x5')
    nx=cm.nlon
    ny=cm.nlat
    ps=npy.zeros([nx, ny], float)
    ps[:,:]=1000.0
    print '>2. build sample  fields for sp, pressure, and two co2'
    
    mod_pres=cm. compute_mod_pres(ps)
    
    cl_sp=field_cl.ctm_field_cl('sp', ps, tra_name='surface_pressure', \
                                    tracer_id=1, \
                                    unit='hPa')
    print npy.shape(mod_pres)
    
    cl_pres=field_cl.ctm_field_cl('mod_pres', mod_pres, tra_name='pressure', \
                                      tracer_id=2, \
                                      unit='hPa')
    
    print '  cl_pres 1', cl_pres[0,0,0]
    print cl_pres[0,0,0]
    data=cl_pres.copy_data()
    data[:,:,:]=500.0
    print '  cl_pres 2', cl_pres[0,0,0]
    
    mod_co2=npy.zeros(npy.shape(mod_pres), float)
    mod_co2[:,:,:]=380.0
    
    cl_co2_1=field_cl.ctm_field_cl('co2',mod_co2, tra_name='co2', tracer_id=3, \
                                    unit='ppm')
    
    mod_co2[:,:,:]=360.0
    
    cl_co2_2=field_cl.ctm_field_cl('co2',mod_co2, tra_name='co2', tracer_id=4, \
                                    unit='ppm')
    
    
    
    

    data_lst=[cl_sp]
    
#, cl_pres, cl_co2_1, cl_co2_2]
    
    

    
    print '  type:', oob.get_ot_type(cl_sp)
    
    print '>3 construct the world' 
    
    cworld=ctm_world_cl('world', data_lst, time_tag="2013.03.11")
    print 'set a grid to the world' 
    
    cworld.set_grid(cm)
    
    print '>4 add data to world'
    
    cworld.add_data(cl_pres)
    cworld.add_data(cl_co2_1)
    cworld.add_data(cl_co2_2)
    d1=cworld[1]
    print ' information on second tracer'
    
    print d1.name
    print d1.dims
    print d1.ndim
    print npy.shape(d1.data)

    print ' information on third tracer'
    
    d1=cworld[2]
    print d1.name
    print d1.dims
    print d1.ndim
    print npy.shape(d1.data)
    unit=d1.get_attr('unit')
    print unit
    
    tx=cworld[0:4]
    print len(tx)
    
    tx=cworld['co2']
    print len(tx)
    
    olon=npy.array([30, 40, 50])
    olat=npy.array([-30, -40, 50])
    
    
    print '>5  test get_gp_slice' 
    
    name_lst, profile_lst=cworld.get_gp_slice(olon, olat, name='co2')
    
    # print npy.shape(profiles)
    print name_lst
    print len(profile_lst)
    
    profiles=profile_lst[0]
    print oob.get_ot_type(profiles)
    
    print npy.shape(profiles)
    
    print '>6 delet data'
    
    del cworld['co2']

    print cworld.ndata
    
    
    
    
    
    

    
    
    
    

        
