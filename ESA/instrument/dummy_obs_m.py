""" class for virtual (dummy) observations for clear scenes 
along satellite orbit 


    Authors: L. Feng, Edinburgh University
    History: v0.9, 2012.06.28
    History: v0.95, 2013.04.23
    
    CLASSES
    ===============================================
    1. virtual_obs_cl: class for storage information of virtual observations
    

    Notes:
    -------------------------------------------------
    1. daily virtual observation is generated by
    ---> get orbit (sampling) location 
    ---> grid orbit to grid boxes provided by the user
    ---> get cloud PDF along observation location
    ---> sample cloud PDF to remove cloud contaminated scenes
    ---> get AOD PDF along observations
    ---> sample AOD PDF to remove heavy aod-loading scenes
    ---> get surface type
    ---> get observation ak and observation error using AOD, SZA etc. 
    ---> get prior profile along observation track
    ---> get dummy observation and associated errors
    
"""
    
import  numpy as npy
import ESA.util.time_module as  tm
import ESA.util.geo_constant as gc
import ESA.util.vertical_profile as vpf  # vertical regrid
import ESA.util.otool_obj as oob
import ESA.util.message_m as msm

# build read orbit 
import ESA.util.otool_var_io as ovar
import ESA.util.otool_ncfile_io as ncfio

def_vobs_varname_lst=['lon', 'lat', 'time', 'obs_pres', \
                          'obs_apr', 'obs_ak', 'oerr', 'obs', \
                          'cnt', 'sza', 'surface']




class virtual_obs_cl:
    
    """
    
    Class for virtual observation information 
    
    Members:
    --------------------------------------------
    1. var_dict:<dict>: dictionary variables
    2. varname_lst:<list>: name of variable to be stored 
    

    Functions:
    ---------------------------------------------
    1. del_var: delete variable
    2. set_var: put variable into self.var_dict
    3. save_var_to_netcdf: save variables in self.var_dict 
    4. gen_daily_obs: generate observations 
    """
    def __init__(self, varname_lst=[]):
        
        """
        Inputs:
        --------------------------------------
        1. varname_lst:<list, t:str>: name of variables to be stored 
        """
        
        self.var_dict={}
        self.varname_lst=varname_lst
    
    def del_var(self, varname):
        """
        
        remove var from self.var_dict
        
        """
        if (varname=='*'):
            # delete all 
            del self.var_dict
            self.var_dict={}
        else:
            if (varname in self.var_dict):
                del self.var_dict[varname]
                
    def set_var(self, varname, var):
        """
        Set var into self.var_dict
        
        Inputs:
        -----------------------------
        1. varname:<str>: variable name 
        2. var:   <array>: variable 
        
        
        Notes:
        --------------------------------------
        1. only varname in self.varname_lst will be updated
        
        """
        if (varname in self.varname_lst):
            self.var_dict.update({varname:var})
            
        
    def save_var_to_netcdf(self, ncflnm):
        
        """
        save variable to disk 

        Inputs:
        -----------------------------------------------
        1. ncflnm:<str>: file name
        
        """
        
        # S1: set diminfo_lst and varinfo_lst 
        initd=0
        
        varinfo_lst=list()
        for varname in self.var_dict:
            var=self.var_dict[varname]
            dims=npy.shape(var)
            if (len(dims)==2):
                # #T1: 2 dimension data
                if (initd<2):
                    
                    # #c: reset diminfo_lst
                    
                    nobs, nlvl=dims[0], dims[1]
                    xnobs=npy.arange(nobs)
                    xnlvl=npy.arange(nlvl)
                    nobs_info=ovar.io_var_cl('nobs', 'i', ['nobs'], xnobs)
                    nlvl_info=ovar.io_var_cl('nlvl', 'i', ['nlvl'], xnlvl)
                    # #c:set dimension for output 
                    diminfo_lst=[nobs_info, nlvl_info]
                    initd=2
                    
                # #c: 2-D var

                var_info=ovar.io_var_cl(varname, 'f', ['nobs', 'nlvl'], var, \
                                            varattr=None)
                
            elif (len(dims)==1):
                # #T2: one-dimension set 
                
                if (initd<1):
                    # #c: set diminfo_lst
                    
                    nobs=dims[0]
                    xnobs=npy.arange(nobs)
                    nobs_info=ovar.io_var_cl('nobs', 'i', ['nobs'], xnobs)
                    diminfo_lst=[nobs_info]
                    initd=1
                
                # 1D var
                var_info=ovar.io_var_cl(varname, 'f', ['nobs'], var, \
                                            varattr=None)
                
            varinfo_lst.append(var_info)
            

        # S2: save data 
        ncfio.ncf_save_var(ncflnm,  varinfo_lst,\
                               diminfo_lst, \
                               create_new=True)
        
    def read_var_from_netcdf(self, ncflnm):
        
        """
        Load variable from netcdf from list
        
        Inputs:
        ------------------------------------------
        1. ncflnm:<str>: file name 
    
        """
        
        var_lst=ncf_read(ncflnm, self.varname_lst)
        
        nvar=len(self.varname_lst)
        for ivar in range(nvar):
            self.set_var(self.varname_lst[ivar], self.var_lst[ivar])
            

    def gen_daily_obs(self, odef, yyyy, mm, dd):
        
        """
    
        Inputs
        --------------------------------------
        1. odef: <vobs_def_cl>: configuration for generating dummy obs
        2. yyyy, mm, dd:<int>: year, month, day
        
        Returns:
        ===========================================
        1. nobs:<int>: number of clear observations (scenes)
    

        Notes:
        -------------------------------------------------
        1. daily virtual observation is generated by
        ---> get orbit (sampling) location 
        ---> grid orbit to grid boxes provided by the user
        ---> get cloud PDF along observation location
        ---> sample cloud PDF to remove cloud contaminated scenes
        ---> get AOD PDF along observations
        ---> sample AOD PDF to remove heavy aod-loading scenes
        ---> get surface type
        ---> get observation ak and observation error using AOD, SZA etc. 
        ---> get prior profile along observation track
        ---> get dummy observation and associated errors
        
        """
    
        rlon=odef.lon
        rlat=odef.lat
        print 'dummy_obs_cl--rlon:', rlon[0], rlon[-1]
        print 'dummy_obs_cl--rlat', rlat[0], rlat[-1]
        
        

        doy=tm.day_of_year(yyyy, mm, dd)
        
        # S1: read in orbit and regrid 
        odef.cl_orb.load_orbit_from_file(yyyy, mm, dd)
        
        orb_data=odef.cl_orb.grid_orbit(rlon, rlat, update_orbit=True)
        
        olon=odef.cl_orb.orb['lon']
        print 'dummy_obs_cl--olon', npy.max(olon), npy.min(olon)
       
        # values
    
        
        olon=npy.where(olon>180, olon-360.0, olon)
        
        olat=odef.cl_orb.orb['lat']
        print 'dummy_obs_cl--olat', npy.max(olat), npy.min(olat)
        

        otime=odef.cl_orb.orb['time']
        ocnt=odef.cl_orb.orb['cnt']
        osza=odef.cl_orb.orb['sza']
        
        
        # S2: sample cloud PDF 
    
        ocld=odef.cl_cld.get_data(olon, olat, yyyy, mm, dd, otime)
        
        clear_cnt=odef.fcld_sample(olon, olat, otime, ocnt,  \
                                       ocld, fpenalty=odef.fcld_penalty, \
                                       **odef.fcld_keywords)
    
    
        
    # ##T: filter cloudy scenes
    
        usd_idx=npy.where(clear_cnt>0)
        usd_idx=npy.squeeze(usd_idx)
        
        if (npy.size(usd_idx)>0):
            olon, olat, otime, ocnt, osza=\
                olon[usd_idx], olat[usd_idx], otime[usd_idx], clear_cnt[usd_idx], osza[usd_idx]
        
        else:
        
            return nobs
        
    
        
        
        # S3: sample AOD 
    
        aod, paod=odef.cl_aod.get_data(olon, olat, \
                                           yyyy, mm, dd, otime)
    
    
        oaod, cnt=odef.faod_sample(olon, olat, otime, ocnt, aod, paod, odef.faod_uplimit)
    
        # #T: filter aod>aod_uplimit scenes
        usd_idx=npy.where((oaod<=odef.faod_uplimit) & (cnt>0))
    
        
    
        usd_idx=npy.squeeze(usd_idx)
    
        olon, olat, otime, ocnt=\
            olon[usd_idx], olat[usd_idx], otime[usd_idx], ocnt[usd_idx]
        
        oaod=oaod[usd_idx]
        osza=osza[usd_idx]
        
        nobs=npy.size(oaod)
        
        if (nobs==0):
            return nobs
    

        
        # S4: get surface type 
    
        olc=odef.cl_lc.get_data(olon, olat, yyyy, mm, dd,otime, **odef.flc_keywords)
    
        ostype=odef.flc_sample(olc, odef.flc_stype_lst)
        
        isurf_type=odef.cl_err.get_surf_type_id(ostype)
        
        # S5: get view mode index 
    
        viewmode_lst=npy.size(oaod)*[odef.viewmode]
        iviewmode=odef.cl_err.get_viewmode_id(viewmode_lst)
    
        # S6:  get averaging kernel 
        
    
        lgp, oak=odef.cl_ak.get_data(osza, oaod, \
                                         iviewmode, \
                                         isurf_type)
        
        # S7: get averaging kernel 
        
        oerr=odef.cl_err.get_data(osza, oaod, \
                                      iviewmode, \
                                      isurf_type)
    
    
        
        # S8: prior profiles used in retrievals 
    
        if (npy.max(lgp.flat)>10):
            opres=lgp
        else:
            # is in log
            
            opres=10.0**(lgp)
        
        if (opres[0,1]>opres[0, 2]):
            do_ob_reverse=True
        else:
            do_ob_reverse=False
    
        opres, oprior, col_obs=\
            odef.cl_apr.get_prior(yyyy, mm, dd, \
                                      olon, olat, opres, \
                                      is_opres_in_log=False,\
                                      do_ob_reverse=do_ob_reverse)
    

        self.set_var('lon', olon)
        self.set_var('lat', olat)
        self.set_var('time', otime)
        self.set_var('obs_apr', oprior)
        self.set_var('obs_ak', oak)
        self.set_var('obs_pres', opres)
        self.set_var('obs', col_obs)
        self.set_var('oerr', oerr)
        self.set_var('cnt', ocnt)
        self.set_var('sza', osza)
        self.set_var('surface', isurf_type)
        
        
        
        return nobs





if (__name__=='__main__'):
   
    
    viewtype='aqua'
    viewmode='nadir'
    yyyy, mm, dd=2009, 3, 1
    menu_flnm='vob_def.cfg'
    if ('.xml' in menu_flnm):
        # #: if the menu is given in xml  file 
        root_menu=menu_m.xml_to_menu(xml_menu_flnm)
    else:
        # if the menu is given in format text file 
        root_menu=menu_m.txt_to_menu(menu_flnm)
    
    odef=vobs_def.vobs_def_cl(yyyy, mm, dd, \
                                  root_menu)
    vobs=virtual_obs_cl(def_vobs_varname_lst)
    
    
    nobs=vobs.gen_daily_obs(odef, yyyy, mm, dd)
    
    sdate=r'%4.4d%2.2d%2.2d' % (yyyy, mm, dd)
    
    ncflnm=viewtype+'.'+viewmode+'.'+sdate+'.nc'
    vobs.save_var_to_netcdf(ncflnm)
    
    
            
        
    
